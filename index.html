<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1.0,
               maximum-scale=1.0, user-scalable=no,
               viewport-fit=cover" />
<title>ë¸Œë¦­ ë¸Œë ˆì´ì»¤ â€“ ì˜¤ë Œì§€</title>
<style>
  :root{
    /* ğŸ§± ë²½ëŒ(ì£¼í™©Â·í…Œë¼ì½”íƒ€) íŒ”ë ˆíŠ¸ */
    --bg:#f6f7fb;         /* í˜ì´ì§€ ë°°ê²½ */
    --fg:#3a332e;         /* ê¸€ì */
    --accent:#ff9e3d;     /* ê³µ ìƒ‰ */
    --paddle:#e7671a;     /* íŒ¨ë“¤ ìƒ‰ */
    --brick1:#b74c2c;
    --brick2:#b74c2c;
    --brick3:#b74c2c;
    --brick4:#b74c2c;
    --brick5:#b74c2c;
    --panel:#ffffff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;
    display:flex;flex-direction:column;align-items:center;gap:12px;
    padding:16px; padding-bottom:calc(16px + env(safe-area-inset-bottom,0));
  }
  header{width:100%;max-width:1100px;display:flex;justify-content:space-between;align-items:center;gap:8px}
  .hud{display:flex;gap:8px;font-weight:700;flex-wrap:wrap}
  .chip{background:var(--panel);padding:6px 12px;border-radius:20px;box-shadow:0 1px 3px rgba(0,0,0,.08)}
  .panel{width:100%;max-width:1100px;display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap}
  .btn{padding:8px 14px;border-radius:20px;border:none;cursor:pointer;background:var(--panel);
       box-shadow:0 1px 3px rgba(0,0,0,.08);font-weight:800}
  .note{font-size:13px;opacity:.85}

  /* ğŸ® ê²Œì„ ì˜ì—­: JSê°€ width/heightë¥¼ ê³„ì‚°í•´ ë„£ìŠµë‹ˆë‹¤ (16:9 ìœ ì§€) */
  .wrap{
    position:relative; width:100%; max-width:1100px;
    background:var(--panel); border-radius:14px; overflow:hidden;
    box-shadow:0 6px 12px rgba(0,0,0,.1); touch-action:none;
  }
  canvas{display:block; width:100%; height:100%; background:transparent}
  .center-msg{
    position:absolute; inset:0; display:grid; place-items:center;
    font-weight:800; color:var(--fg); text-align:center; font-size:18px;
    background:rgba(255,255,255,.55); padding:12px
  }
  .hidden{display:none}

  /* â¬…ï¸â¡ï¸ í° í„°ì¹˜ ë²„íŠ¼(ìº”ë²„ìŠ¤ ë°–, ê²¹ì¹¨ ì—†ìŒ) */
  .touch-controls{width:100%;max-width:1100px;display:flex;gap:10px;margin-top:10px}
  .touch-btn{
    flex:1;min-height:56px;border:none;border-radius:12px;
    background:#eee;font-size:18px;font-weight:900;color:#333;
    box-shadow:0 1px 3px rgba(0,0,0,.06)
  }
  @media (min-width:801px){ .touch-controls{display:none} } /* ë°ìŠ¤í¬í†±ì€ ìˆ¨ê¹€ */
</style>
</head>
<body>
  <header>
    <h2>ğŸ§± ë¸Œë¦­ ë¸Œë ˆì´ì»¤ â€“ ì˜¤ë Œì§€</h2>
    <div class="hud">
      <div class="chip">ì ìˆ˜ <span id="score">0</span></div>
      <div class="chip">ìŠ¤í…Œì´ì§€ <span id="stage">1</span></div>
      <div class="chip">ëª©ìˆ¨ <span id="lives">3</span></div>
    </div>
  </header>

  <section class="panel">
    <span class="note">â† â†’ / A D Â· Space/íƒ­ ì‹œì‘Â·ì¼ì‹œì •ì§€ Â· í™”ë©´ ë“œë˜ê·¸ ë˜ëŠ” ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì´ë™</span>
    <div>
      <button id="startBtn" class="btn">â–¶ ì‹œì‘/ì¼ì‹œì •ì§€</button>
      <button id="resetBtn" class="btn">âŸ³ ë¦¬ì…‹</button>
    </div>
  </section>

  <div class="wrap" id="wrap">
    <canvas id="game"></canvas>
    <div id="msg" class="center-msg">íƒ­(ë˜ëŠ” Space)ìœ¼ë¡œ ì‹œì‘!</div>
  </div>

  <div class="touch-controls">
    <button class="touch-btn" id="leftBtn">â—€ ì™¼ìª½</button>
    <button class="touch-btn" id="rightBtn">ì˜¤ë¥¸ìª½ â–¶</button>
  </div>

<script>
(()=> {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const wrap = document.getElementById('wrap');
  const msgEl = document.getElementById('msg');
  const scoreEl = document.getElementById('score');
  const stageEl = document.getElementById('stage');
  const livesEl = document.getElementById('lives');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');

  // ğŸ¨ CSS ë³€ìˆ˜ â†’ ì‹¤ì œ ìƒ‰ìƒ
  function theme(){
    const css = getComputedStyle(document.documentElement);
    const get = k => css.getPropertyValue(k).trim();
    return {
      brick:[get('--brick1'),get('--brick2'),get('--brick3'),get('--brick4'),get('--brick5')],
      paddle:get('--paddle'), ball:get('--accent')
    };
  }
  let COLORS = theme();

  // ë…¼ë¦¬ ì¢Œí‘œ(=CSS í”½ì…€) í­/ë†’ì´
  let viewW = 0, viewH = 0, DPR = 1;

  // ğŸ“ 16:9 ìë™ ë§ì¶¤ (ëª¨ë“  ê¸°ê¸°)
  function fitCanvas(){
    DPR = window.devicePixelRatio || 1;

    const vw = document.documentElement.clientWidth;
    const vh = window.innerHeight;

    const headerH = document.querySelector('header').getBoundingClientRect().height;
    const panelH  = document.querySelector('.panel').getBoundingClientRect().height;
    const tcEl    = document.querySelector('.touch-controls');
    const touchH  = (tcEl && getComputedStyle(tcEl).display!=='none') ? tcEl.getBoundingClientRect().height : 0;

    const margin  = 32;
    const availH  = Math.max(220, vh - headerH - panelH - touchH - margin);
    const maxW    = Math.min(1100, vw - 16*2);

    let w = maxW;
    let h = Math.round(w * 9/16);
    if (h > availH) { h = availH; w = Math.round(h * 16/9); }

    // DOM í¬ê¸°
    wrap.style.width = w + 'px'; wrap.style.height = h + 'px';
    canvas.style.width = w + 'px'; canvas.style.height = h + 'px';

    // ì‹¤ì œ ìº”ë²„ìŠ¤ ë²„í¼(ì¥ì¹˜ í”½ì…€)
    canvas.width  = Math.round(w * DPR);
    canvas.height = Math.round(h * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);

    viewW = w; viewH = h;

    // ì •ì§€ ì¤‘ì—” ì¤‘ì•™ìœ¼ë¡œ ì¬ë°°ì¹˜
    if(!running){
      paddle.x = viewW/2 - paddle.w/2;
      paddle.y = viewH - paddle.marginBottom - paddle.h; // ì•„ë˜ ì—¬ë°± ë°˜ì˜
      ball.x   = viewW/2;
      ball.y   = paddle.y - 30;
    }
  }
  window.addEventListener('resize', fitCanvas, {passive:true});
  window.addEventListener('orientationchange', ()=> setTimeout(fitCanvas, 200));

  // ğŸ® ê²Œì„ ìƒíƒœ
  let running=false, over=false;
  let score=0, stage=1, lives=3;

  const paddle = {w:110,h:14,x:0,y:0,speed:8, marginBottom:14}; // ë°”ë‹¥ì—ì„œ 14px ë„ì›€
  const ball   = {x:0,y:0,r:8,vx:4,vy:-4};

  // ë°°ì¹˜ ì„¤ì • (ë²½ëŒê³¼ íŒ¨ë“¤ì˜ ê°„ê²© ë„‰ë„‰íˆ)
  const conf   = {
    rows:5, cols:10,
    brickH:20, pad:8,
    side:24,
    top:50,            // í™”ë©´ ìœ„ì—ì„œ ì‹œì‘
    gapToPaddle:140    // ë²½ëŒ í•˜ë‹¨ê³¼ íŒ¨ë“¤ ì‚¬ì´ ìµœì†Œ ê°„ê²©
  };
  let bricks=[];

  function buildStage(){
    bricks=[];
    // ë…¼ë¦¬ ì¢Œí‘œ(viewW)ë¡œ ê³„ì‚°
    const areaW = viewW - conf.side*2 - (conf.cols-1)*conf.pad;
    const bw = areaW / conf.cols;

    // ë²½ëŒ ì „ì²´ ë†’ì´
    const bricksHeight = conf.rows*conf.brickH + (conf.rows-1)*conf.pad;

    // íŒ¨ë“¤ê³¼ ê±°ë¦¬ í™•ë³´: topì„ ìë™ ì¡°ì •
    let top = conf.top;
    const minPaddleY = top + bricksHeight + conf.gapToPaddle;
    const desiredPaddleY = viewH - paddle.marginBottom - paddle.h;
    if (desiredPaddleY < minPaddleY) {
      // í™”ë©´ì´ ë§¤ìš° ë‚®ë‹¤ë©´, topì„ ë” ìœ„ë¡œ ì˜¬ë ¤ì„œ ê°„ê²© í™•ë³´
      top = Math.max(20, top - (minPaddleY - desiredPaddleY));
    }

    for(let r=0;r<conf.rows;r++){
      for(let c=0;c<conf.cols;c++){
        bricks.push({
          x: conf.side + c*(bw+conf.pad),
          y: top + r*(conf.brickH+conf.pad),
          w: bw, h: conf.brickH,
          color: COLORS.brick[r % COLORS.brick.length]
        });
      }
    }

    // íŒ¨ë“¤ ìœ„ì¹˜ ìµœì¢… í™•ì •(ë…¼ë¦¬ ì¢Œí‘œ)
    paddle.y = viewH - paddle.marginBottom - paddle.h;
    if(!running) { ball.y = paddle.y - 30; }
  }

  function roundedRect(x,y,w,h,r=4){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function resetGame(){
    COLORS = theme();
    score=0; stage=1; lives=3;
    scoreEl.textContent=score; stageEl.textContent=stage; livesEl.textContent=lives;
    fitCanvas();
    ball.vx=4; ball.vy=-4;
    buildStage();
    running=false; over=false;
    msgEl.textContent="íƒ­(ë˜ëŠ” Space)ìœ¼ë¡œ ì‹œì‘!"; msgEl.classList.remove('hidden');
  }

  function toggleRun(){
    if(over){ resetGame(); return; }
    running=!running;
    msgEl.classList.toggle('hidden', running);
    if(!running && !over) msgEl.textContent="ì¼ì‹œì •ì§€ (íƒ­/Spaceë¡œ ì¬ì‹œì‘)";
  }

  document.getElementById('startBtn').onclick = toggleRun;
  document.getElementById('resetBtn').onclick = resetGame;

  // âŒ¨ï¸ í‚¤ë³´ë“œ
  let left=false,right=false;
  document.addEventListener('keydown',e=>{
    if(e.code==="Space"){ e.preventDefault(); toggleRun(); }
    if(e.key==="ArrowLeft"||e.key==="a"||e.key==="A") left=true;
    if(e.key==="ArrowRight"||e.key==="d"||e.key==="D") right=true;
  });
  document.addEventListener('keyup',e=>{
    if(e.key==="ArrowLeft"||e.key==="a"||e.key==="A") left=false;
    if(e.key==="ArrowRight"||e.key==="d"||e.key==="D") right=false;
  });

  // ğŸ– ìº”ë²„ìŠ¤ íƒ­/ë“œë˜ê·¸ ì´ë™
  let dragging=false;
  wrap.addEventListener('pointerdown', (e)=>{ toggleRun(); dragging=true; movePaddle(e); });
  wrap.addEventListener('pointermove', (e)=>{ if(dragging) movePaddle(e); });
  wrap.addEventListener('pointerup',   ()=>{ dragging=false; });
  function movePaddle(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left); // ë…¼ë¦¬(px)
    paddle.x = Math.max(0, Math.min(viewW - paddle.w, x - paddle.w/2));
  }

  // â¬…ï¸â¡ï¸ í° í„°ì¹˜ ë²„íŠ¼
  function bindHold(btn, dir){
    let hold=false, raf=null;
    const step=()=>{ if(!hold) return; paddle.x += dir*paddle.speed*1.2; clampPaddle(); raf=requestAnimationFrame(step); };
    btn.addEventListener('pointerdown', ()=>{ hold=true; step(); });
    const stop=()=>{ hold=false; if(raf) cancelAnimationFrame(raf); };
    btn.addEventListener('pointerup', stop);
    btn.addEventListener('pointerleave', stop);
  }
  bindHold(leftBtn, -1);
  bindHold(rightBtn, 1);

  function clampPaddle(){ paddle.x = Math.max(0, Math.min(viewW - paddle.w, paddle.x)); }

  // ğŸ” ê²Œì„ ë£¨í”„ (ëª¨ë“  ê²½ê³„ì— viewW/viewH ì‚¬ìš©)
  function update(){
    if(left) paddle.x -= paddle.speed;
    if(right) paddle.x += paddle.speed;
    clampPaddle();

    ball.x += ball.vx; ball.y += ball.vy;

    // ë²½ ì¶©ëŒ
    if(ball.x < ball.r){ ball.x = ball.r; ball.vx *= -1; }
    if(ball.x > viewW - ball.r){ ball.x = viewW - ball.r; ball.vx *= -1; }
    if(ball.y < ball.r){ ball.y = ball.r; ball.vy *= -1; }

    // íŒ¨ë“¤
    if(ball.y+ball.r >= paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.w){
      ball.vy *= -1;
      const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2); // -1~1
      ball.vx = 5 * hit;
      ball.y  = paddle.y - ball.r;
    }

    // ë²½ëŒ
    for(let i=0;i<bricks.length;i++){
      const b = bricks[i];
      if(ball.x > b.x && ball.x < b.x+b.w && ball.y-ball.r < b.y+b.h && ball.y+ball.r > b.y){
        ball.vy *= -1;
        bricks.splice(i,1);
        score += 10; scoreEl.textContent = score;
        break;
      }
    }

    // ë°”ë‹¥
    if(ball.y > viewH){
      lives--; livesEl.textContent = lives;
      if(lives<=0){
        over=true; running=false; msgEl.textContent="ê²Œì„ ì˜¤ë²„! Space/íƒ­ìœ¼ë¡œ ì¬ì‹œì‘"; msgEl.classList.remove('hidden');
      }else{
        ball.x = viewW/2; ball.y = paddle.y - 30; ball.vx=4; ball.vy=-4;
        paddle.x = viewW/2 - paddle.w/2;
        running=false; msgEl.textContent="ì¬ë„ì „! Space/íƒ­ìœ¼ë¡œ ì‹œì‘"; msgEl.classList.remove('hidden');
      }
    }

    // í´ë¦¬ì–´ â†’ ê°„ê²© ìœ ì§€í•œ ì±„ ë‹¤ìŒ ìŠ¤í…Œì´ì§€
    if(bricks.length === 0){
      stage++; stageEl.textContent = stage;
      conf.rows = Math.min(7, conf.rows + 1); // ë„ˆë¬´ ë¹½ë¹½í•´ì§€ì§€ ì•Šê²Œ ìƒí•œ
      buildStage();
      ball.x = viewW/2; ball.y = paddle.y - 30;
      running=false; msgEl.textContent=`ìŠ¤í…Œì´ì§€ ${stage-1} í´ë¦¬ì–´! Space/íƒ­ìœ¼ë¡œ ê³„ì†`; msgEl.classList.remove('hidden');
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // ë²½ëŒ(ë¼ìš´ë“œ)
    bricks.forEach(b=>{
      ctx.fillStyle = b.color;
      roundedRect(b.x, b.y, b.w, b.h, 4);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,.12)';
      ctx.stroke();
    });

    // íŒ¨ë“¤
    ctx.fillStyle = COLORS.paddle;
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

    // ê³µ
    ctx.beginPath();
    ctx.fillStyle = COLORS.ball;
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();
  }

  function loop(){ if(running) update(); draw(); requestAnimationFrame(loop); }

  resetGame();
  loop();
})();
</script>
</body>
</html>
